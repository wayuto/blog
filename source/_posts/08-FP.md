---
title: 08-函数式编程
date: 2026-02-28 19:21:14
tags:
---

在前面的几章，我们了解了`Alum`的基本特性与语法，并能够用这种`命令式编程`的方式编写一些简单的程序，这一章，我们将介绍`Alum`的`函数式编程`特性。总体来说，`Alum`作为笔者的个人项目，还是一门非常简单的语言，但他也在向`函数式语言`发展，就现在而言，已经实现了`匿名函数`与`高阶函数`两个特性。

1. ## 匿名函数
`匿名函数`也常称`Lambda函数`，顾名思义，它是一个没有名字的函数，遗憾的是，`Alum`的匿名函数目前还没有实现`闭包`这个高级特性，也就是捕获外部变量，但也在开发的计划内了，在`Alum`中，匿名函数的语法如下：
```alum
lamb(P: PT): RT expr
```
是不是看起来和不同函数很像？是的，它实际上在汇编层面创建了一个`_lambdaN`的函数，并返回了这个函数的指针，所以可以将这个指针赋值给一个变量，例如
```alum
let f: int(int) = lamb(n: int): int return n + 1
```
并通过`f()`调用这个匿名函数

2. ## 高阶函数
`高阶函数`听起来就很高级，但实际上，它就是指一个函数，其参数或返回值也是一个函数，举个简单的例子
```alum
fun judge(method: bool(int), a: int): bool {
    return method(a)
}

fun main() {
    let n: int = 1
    let gt0: bool(int) = lamb(n: int): bool {
        return n > 0
    }
    let result: bool = judge(gt0, n)
}
```
在这个例子中，我们定义了函数`judge`，它接受一个`bool(int)`类型的函数和一个整数，并判断整数是否符合一定的条件，在`main`函数中，我们定义了匿名函数`gt0`，判断给定的整数是否大于`0`。相信读者一定已经有了初步认知，接下来，我们就可以实现一个有趣的函数：
```alum
$import "io.al"

fun f(): any {
    println("Called f()")
    return f
}
```
在[03-Types](03-Types.md)中我们介绍过，any用于自动类型推导，这样就省略了冗长的类型，这里的函数`f`执行后会打印`Called f()`并返会它本身，于是便可以做到通过`()`的数量控制调用的次数：
```alum
fun main() {
    f()()()
}
```
这样就会打印三次`Called f()`